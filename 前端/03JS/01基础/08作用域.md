# 作用域

> 通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。

JavaScript（es6前）中的作用域有两种：

- 全局作用域
- 局部作用域（函数作用域）

### 1.JS没有块级作用域

- 块作用域由 { } 包括。

- 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：
  
  java有块级作用域：
  
  ```java
  if(true){
    int num = 123;
    system.out.print(num);  // 123
  }
  system.out.print(num);    // 报错
  ```
  
  以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用；
  
  而与之类似的JavaScript代码，则不会报错：
  
  Js中没有块级作用域（在ES6之前）

```js
  if(true){
    var num = 123;
    console.log(123); //123
  }
  console.log(123);   //123
```

### 2.预解析

> - 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。
> 
> - 代码执行： 从上到下执行JS语句。
>   
>   **预解析会把变量和函数的声明在代码执行之前执行完成。**

#### (1)变量预解析

> 预解析也叫做变量、函数提升。
> 变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。

```js
console.log(num);  // 结果是多少？
var num = 10;      // ？
```

```
结果：undefined

注意：**变量提升只提升声明，不提升赋值**
```

#### (2)函数预解析

> 函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。

```js
fn();
function fn() {
    console.log('打印');
}
```

```
结果：控制台打印字符串 --- ”打印“ 

注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！    
```

#### (3)函数表达式声明函数(匿名函数)问题

> 函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：
> 
> 匿名函数声明  当做变量处理  无法调用

```js
fn();
var  fn = function() {
    console.log('想不到吧');
}
```

```
结果：报错提示 ”fn is not a function"

解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；
而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用
```
